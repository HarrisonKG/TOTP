
import sys
import qrcode
import time
import math
import hashlib
import hmac
import base64
import struct




def main():
	user_id = "kristen@gmail.com"
	issuer = "ExampleCompany"
	secret = "ERJCJYEQVJHYDVKUFXQUNGDE"

	# generate a PNG of the QR code that encodes the URI that Google Authenticator expects.
	if (len(sys.argv) > 1 and sys.argv[1] == "--generate-qr"):
		img = qrcode.make("otpauth://totp/" + issuer + ":" + user_id + "?secret=" + secret + "&issuer=" + issuer + "&algorithm=SHA1&digits=6&period=30")
		img.save("qrcode.png")

	# generate OTP which matches the OTP generated by GA for that 30-second period and print it to the screen
	elif (len(sys.argv) > 1 and sys.argv[1] == "--get-otp"):
		while(1):
			generate_otp(secret);
			time.sleep(30)

	else:
		print("Incorrect usage, please run either python3 prob2.py --generate-qr or python3 prob2.py --get-otp")




def generate_otp(key):
	# current unix time as the number of seconds since the epoch
	current_time = time.time()
	time_step = 30
	# T = Floor(current unix time - T0) / X
	time_factor = math.floor(current_time / time_step)
	

	# TOTP is the time-based variant of the HOTP algo which is based on HMAC-SHA-1
	# HOTP(K,C) = Truncate(HMAC-SHA-1(K,C)) where K is shared key and C is counter
	# TOTP replaces C with T, derived from time reference and time step
	# TOTP = HOTP(K,T) where T is the # of time steps between initial counter and unix time
	# 	   = Truncate(HMAC-SHA-1(K,T)) where K is shared key and T = Floor(current unix time - T0) / X


	# 1. calculate hmac sha-1 value = HMAC-SHA-1(K,T):

	# turn key into bytes
	key_bytes = base64.b32decode(key)

	# put message (time factor) into bytes
	# struct.pack converts time int to 8-byte number, by using parameter >Q to indicate big-endian unsigned long long int 
	time_bytes = struct.pack(">Q", time_factor)

	# create hmac and call digest to create signature in binary (20-byte string)
	sig = hmac.new(key_bytes, time_bytes, hashlib.sha1).digest()


	# 2. truncate 20-byte string into 4-byte string:

	# calculate offset value as the low-order 4 bits of the last byte of the signature; will be between 0 and 15, inclusive
	offset = sig[19] & 0xf
	#print(offset)

	# extract 4 bytes using offset
	extracted_bytes = sig[offset:offset+4]
	#print(extracted_bytes)


	# 3. calculate TOTP value = truncated_string mod 10^6 for a 6-digit passcode:

	# turn bytes back into int value (>I indicates big-endian unsigned int, or 4 bytes)
	int_digits = struct.unpack(">I", extracted_bytes)
	#print(int_digits)

	# mask most significant bit to avoid signed / unsigned int errors
	int_code = int_digits[0] & 0x7fffffff
	#print(int_code)

	# mod with 10^6 to reduce to 6-digit code
	modded_code = int_code % 1000000

	# pad with zeroes if necessary to make 6 digits
	print("%06d" % modded_code)




if __name__ == "__main__":
	main()


